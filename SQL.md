# Подготовка к собеседованию по SQL
## Оглавление
* [Ключи](#Ключи)
* [Номарлизация](#Номарлизация)
* [Индексы](#Индексы)
* [Подзапросы](#Подзапросы)
* [CTE](#CTE)
* [Группировка и агрегация](#Группировка-и-агрегация)
* [Функции](#Функции)
    * [Оконные функции](#Оконные-функции)
* [Общие вопросы](#Общие-вопросы)
* [Задачки](#Задачки)
* [Источники](#Источники)
---
## Другие файлы
* [Python](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Python.md)
* [Scala](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Scala.md)  -- todo
* [Spark](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Spark.md)
* [Общая информация](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Common.md)
* [Вопросы работодателю](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Questions%20for%20employer.md)
---
## Ключи
[Go Back](#оглавление)
* Первичный ключ (Primary Key)
    * Первичный ключ — столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице
    * Он гарантирует, что каждая запись в таблице будет иметь уникальное значение ключа
    * Null-значения не допускаются
* Внешний ключ (Foreign Key)
    * Внешний ключ поддерживает ссылочную целостность, обеспечивая связь между данными в двух таблицах
    * Внешний ключ в дочерней таблице ссылается на первичный или уникальный ключ в родительской таблице
    * Ограничение внешнего ключа предотвращает действия, которые разрушают связи между дочерней и родительской таблицами
* Уникальный (Unique Key)
    * Однозначно идентифицирует одну строку в таблице
    * Допустимо множество уникальных ключей в одной таблице
    * Могут быть допустимы NULL-значения
---
## Номарлизация
[Go Back](#оглавление)
* Нормальная форма — свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности, потенциально приводящей к логически ошибочным результатам выборки или изменения данных
* Нормальная форма определяется как совокупность требований, которым должно удовлетворять отношение
* Процесс преобразования отношений базы данных к виду, отвечающему нормальным формам, называется **нормализацией**
* **Нормализация** это процесс организации данных в базе данных
    * Создание таблиц
    * Установление связей между ними в соответствии с правилами
        * Для защиты данных
        * Для повышения гибкости базы данных, устраняя избыточность и несогласованную зависимость
* Цели нормализации
    * Устранить избыточность и дублирование данных
    * Минимизировать потенциальные векторы ошибок
    * Обеспечить высокую производительность при выполнении запросов
* Виды нормализации
    * _Чтобы перейти к последующей нормализации необходимо выполнить все предыдущие_
    * Первая нормальная форма
        * Устраните повторяющиеся группы в отдельных таблицах
        * Создайте отдельную таблицу для каждого набора связанных данных
        * Идентифицируйте каждый набор связанных данных с помощью первичного ключа
    * Вторая нормальная форма
        * Создайте отдельные таблицы для наборов значений, относящихся к нескольким записям
        * Свяжите эти таблицы с помощью внешнего ключа
    * Третья нормальная форма
        * Исключите поля, которые не зависят от ключа
    * Другие
        * _Другие формы нормализации обычно не используются, так как дают немного выгоды при больших трудозатратах_
        * Нормальная форма Бойса-Кодда
        * Четвертая нормальная форма
        * Пятая нормальная форма
        * Доменно-ключевая нормальная форма
        * Шестая нормальная форма
* Денормализация
    * Стратегия применяемая к уже нормализованной базе данных с целью повышения ее производительности
    * Поместить избыточные данные туда, где они смогут принести максимальную пользу
        * Логика в том, чтобы снизить время исполнения определенных запросов через упрощение доступа к данным или через создание таблиц с результатами отчетов, построенных на основании исходных данных
    * Непременное условие процесса денормализации — наличие нормализованной базы
    * Когда полезно использовать
        * Сохранение исторических данных
        * Повышение производительности запросов
        * Ускорение создания отчетов
        * Предварительные вычисления часто запрашиваемых значений
    * Минусы
        * Место на диске
        * Документация
        * Замедление других операций
        * Больше кода
Что такое нормализация и каковы ее преимущества
Объясните различные типы нормализации.
Что вы подразумеваете под денормализацией
---
## Индексы
[Go Back](#оглавление)
* Индекс представляет собой структуру, которая хранится на диске и предназначена для столбцов таблицы, а также для объектов типа представления (Views)
* Индекс состоит из ключей
* Главная особенность индексов заключается в скорости поиска данных, которая достигается за счёт того, что индекс состоит из структуры (структуры сбалансированного дерева), которая оптимизирована под поиск
* Типы индексов
    * Уникальный (Unique index) — все значения встречаются только один раз. Если в столбец с уникальным индексом попробовать добавить неуникальное значение, то возникнет ошибка
    * Неуникальный (Non-unique index) — индекс, при котором значения могут повторяться
    * Простой (Simple index) — индекс, состоящий из одного поля
    * Составной (Composite Index) — индекс, который строится по нескольким столбцам таблицы. В данном типе индекса расположение полей является важным
    * Древовидный (B-tree index) — индекс, который представлен в виде корневой вершины и узлов
    * Частичный (Partial Indexes) — индекс, который состоит из подмножеств строк таблицы по определенному выражению
### Кластеризованные и некластеризованные индексы
|Кластеризованный индекс|Некластеризованный индекс|
|-----------------------|-------------------------|
|Производит сортировку и физическое хранение данных в соответствии с правилом сортировки|Не упорядочивает хранение данных физически. Вместо этого используются метки для доступа к данным|
|Данные хранятся на конечных листьях (узлах) индекса|Не хранит данные на конечных листьях (узлах) индекса|
|Занимает много места на диске|Занимает мало места на диске|
|Быстрый доступ к данным|Медленный доступ к данным|
|Дополнительное место на диске не нужно|Необходимо дополнительное место на диске в связи с тем, что индекс хранится отдельно от данных|
|Может повысить производительность при извлечении требуемых данных|Применяется только к тем столбцам, которые используются в запросах с соединениями (join)|
---
## Подзапросы
[Go Back](#оглавление)
* Это SELECT-запрос, вложенный в другой запрос или подзапрос
* Типы
    * Скалярные - возвращают единственное значение
    * Табличные - возвращают множество значений
* Коррелированный подзапрос
    * Ссылается на значения столбцов внешнего запроса
    * Коррелированный подзапрос выполняется для каждой строки основного запроса
    * В момент выполнения подзапроса значения столбцов внешнего запроса являются константами
``` SQL
SELECT *
FROM product_price pp
WHERE pp.price = ( SELECT min(ppm.price)
                   FROM product_price ppm
                   WHERE ppm.product_id = pp.product_id )
ORDER BY pp.product_id, pp.price, pp.store_id
```
---
## CTE
[Go Back](#оглавление)
* Общее табличное выражение (CTE) — это временный результат выполнения SQL-выражения, который можно использовать в другом SQL-выражении. CTE позволяет упрощать сложные SQL-запросы, разбивая их на составные части
``` SQL
WITH store_sales AS (
    SELECT store, SUM(amount) AS total_sales
    FROM orders
    GROUP BY store
), top_stores AS (
    SELECT store
    FROM store_sales
    WHERE total_sales > (SELECT SUM(total_sales)/10 FROM store_sales)
)
SELECT store,
       book,
       SUM(quantity) AS book_quantity,
       SUM(amount) AS book_sales
FROM orders
WHERE store IN (SELECT store FROM top_stores)
GROUP BY store, book;
```
---
## Группировка и агрегация
[Go Back](#оглавление)
* Группировка (`GROUP BY`)
    * Группировка данных позволяет объединить одинаковые значения в заданных полях в группы, а затем выполнять подсчеты для каждой группы
    * Следует иметь в виду, что для `GROUP BY` все значения NULL трактуются как равные, т.е. при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу
* Агрегация
    * Суть процесса агрегации — преобразовать большой набор строк в единственное значение
    * К наиболее часто применяемым можно отнести функции `SUM` , `MIN` , `MAX` , `AVG` и `COUNT`
---
## Функции
[Go Back](#оглавление)
### Функция vs Хранимая процедура
|Функции|Хранимые процедуры|
|-------|------------------|
|Функция имеет возвращаемый тип и возвращает значение|Хранимая процедура не имеет возвращаемого типа, но имеет выходные аргументы|
|Использование DML (insert, update, delete) запросов внутри функции невозможно. В функциях разрешены только SELECT-запросы|Использование DML-запросов (insert, update, delete) возможно в хранимой процедуре|
|Функция не имеет выходных аргументов|Хранимая процедура имеет и входные, и выходные аргументы|
|Вызов хранимой процедуры из функции невозможен|Использование или же управление транзакциями возможно в хранимой процедуре|
|Вызов функции внутри SELECT запросов возможен|Вызов хранимой процедуры из SELECT запросов невозможно|
### Оконные функции
* Это функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце
* При использовании оконных функций количество строк в запросе не уменьшается по сравнении с исходной таблицей
    * В отличие от агрегации с группировкой
* Классы оконных функций
    * Агрегирующие (Aggregate)
        * AVG - вычисления среднего значения числового столбца в таблице
        * COUNT - подсчета количества записей в таблице
            * `count(*)` - возвращает все записи в таблице
            * `count(col)`- возвращает количество записей конкретного столбца (только NOT NULL)
            * `count(DISTINCT col)` - возвращает количество только разных записей конкретного столбца (только NOT NULL)
        * MAX - вычисления максимального значения
        * MIN - вычисления минимального значения
        * SUM - вычисления суммы значений числового столбца в таблице
   ``` SQL
   select name, subject, grade,
   sum(grade) over (partition by name) as sum_grade,
   from student_grades;
   ```
    * Ранжирующие (Ranking)
        * В ранжирующих функция под ключевым словом `OVER` обязательным идет указание условия `ORDER BY`, по которому будет происходить сортировка ранжирования
        * Для SQL пустые `NULL` значения будут определяться одинаковым рангом
        * ROW_NUMBER - проставляет возрастающую нумерацию строк
        * DENSE_RANK - как ROW_NUMBER, при этом ставит одинаковый номер для строк с одинаковым значением поля сортировки
        * RANK - как DENSE_RANK, при этом делает пропуски по количеству повторившихся значений
        * NTILE - равномерно разбивает результат на количество указанных групп по условию сортировки 
   ``` SQL
   select name, subject, grade,
   row_number() over (partition by name order by grade desc),
   from student_grades;
   ```
    * Функции смещения (Value)
        * Это функции, которые позволяют перемещаясь по выделенной партиции таблицы обращаться к предыдущему значению строки или крайним значениям строк в партиции
        * FIRST_VALUE - возвращает первое в упорядоченном наборе значений
        * LAST_VALUE - возвращает последнее в упорядоченном наборе значений
        * NTH_VALUE - возвращает **n**-ое в упорядоченном наборе значений
        * LAG - возвращает значения из предыдущей строки в таблице
        * LEAD - возвращает значения из следующей строки в таблице
   ``` SQL
   select name, quartal, subject, grade, 
   lag(grade) over (order by quartal) as previous_grade,
   from grades_quartal
   ```
#### Форточки
* Благодаря `RANGE BETWEEN` и `ROWS BETWEEN` можно менять "окно" над которым считается оконная функция
* Ключевые слова
    * `UNBOUNDED PRECEDING` - первая строка партиции
    * `CURRENT ROW` - текущая строка
    * `UNBOUNDED FOLLOWING` - последняя строка 
* Пример
``` SQL
SELECT *,
LAST_VALUE(id)
    OVER(PARTITION BY dept_name
         ORDER BY salary DESC
         RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
         as poorest_id
FROM work
``` 
* ROWS - дубли считаются отдельными строками
    * То есть, напрмер, когда мы берем расчет ДО какой-то строки, а она будет дублированная, то дубль не попадет в выборку
* RANGE - дубли считаются одной строкой
---
## Общие вопросы
[Go Back](#оглавление)
### Подмножества SQL
* DDL (Data Definition Language) – это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их
    * CREATE – используется для создания объектов базы данных
    * ALTER – используется для изменения объектов базы данных
    * DROP – используется для удаления объектов базы данных
* DML (Data Manipulation Language) – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими
    * SELECT – осуществляет выборку данных
    * INSERT – добавляет новые данные
    * UPDATE – изменяет существующие данные
    * DELETE – удаляет данные
* DCL (Data Control Language) – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных
    * GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом
    * REVOKE – отзывает выданные разрешения
    * DENY – задаёт запрет, имеющий приоритет над разрешением
* TCL (Transaction Control Language) – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены
    * BEGIN TRANSACTION – служит для определения начала транзакции
    * COMMIT TRANSACTION – применяет транзакцию
    * ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции
    * SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции
### Транзакции 
* Это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку
* Транзакционные базы данных (базы, работающие через транзакции) выполняют требования **ACID**, которые обеспечивают безопасность данных
* **ACID**
    * Atomicity — Атомарность
        * Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния
    * Consistency — Согласованность
        * Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты
    * Isolation — Изолированность
        * Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат
    * Durability — Надёжность    
        * Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя
В чем разница между операторами DELETE и TRUNCATE?
В чем разница между предложениями HAVING и WHERE
В чем разница между типом данных CHAR и VARCHAR в SQL?
подстановочные знаки
### Constraints
* Ограничение (constraints) — это ограничение типа значений, которое накладывается на один или несколько столбцов таблицы. Это позволяет поддерживать точность и целостность данных в таблице БД
* Виды
    * NOT NULL
    * PRIMARY KEY
    * UNIQUE
    * DEFAULT
    * FOREIGN KEY
    * CHECK
### Представления
* Представление (**VIEW**) — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению
* Представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему
* Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности)
### INSERT INTO SELECT
* INSERT INTO SELECT копирует данные из одной таблицы и вставляет их в другую таблицу
### COALESCE
* Специальное выражение, которое вычисляет по порядку каждый из своих аргументов и на выходе возвращает значение первого аргумента, который был не NULL
### Типы СУБД
* Реляционные
* Ключ-значение
* Документо-ориентированные
* Базы данных временных рядов
* Графовые базы данных
* Поисковые базы данных (Search Engines)
* Объектно-ориентированные базы данных
* RDF (Resource Description Framework)
* Wide Column Stores
* Мультимодальные СУБД
* Native XML СУБД
* GEO/GIS (пространственные) и специализированные  СУБД
* Event СУБД (баз данных переходов состояний)
* Контентные СУБД
* Навигационные (Navigational) СУБД
* Векторные базы данных
* Подробнее о них можно прочитать тут - https://habr.com/ru/companies/amvera/articles/754702/
### Советы по оптимизации производительности 
* Используйте EXISTS вместо IN для проверки существования данных
* Избегайте использования оператора SELECT *. Перечисляйте имена требуемых столбцов.
* Выбирайте подходящий тип данных
* Если возможно, избегайте nchar и nvarchar, поскольку эти типы данных занимают вдвое больше памяти по сравнению с char и varchar
* Избегайте использования NULL в полях фиксированной длины. Если NULL необходим, используйте поля переменной длины (varchar), которые занимают меньше места для хранения NULL
* Избегайте предложения HAVING. Предложение HAVING требуется, если вы в дальнейшем хотите фильтровать результаты по значениям агрегатных функций
* Создавайте кластеризованный и некластеризованные индексы
* Придерживайтесь небольших кластеризованных индексов, т.к. ключи кластеризованного индекса могут также присутствовать в некластеризованных индексах
* Наиболее селективные столбцы должны следовать самыми левыми в некластеризованном индексе
* Удаляйте неиспользуемые индексы
* Лучше создавать индексы на целочисленных столбцах, а не на символьных. Целочисленные значения потребляют меньше накладных расходов, чем символьные значения
* Используйте соединения вместо подзапросов
* Используйте выражения WHERE для ограничения результирующих таблиц, создаваемых соединениями
* Используйте TABLOCKX при вставке в таблицу и TABLOCK при слиянии
* Используйте WITH (NOLOCK) при выборке данных из таблиц
* Используйте SET NOCOUNT ON и TRY- CATCH во избежание тупика
* Избегайте курсоров по причине их низкой производительности
* Используйте табличные переменные вместо временных таблиц. Использование временных таблиц требует взаимодействия с базой данных TempDB, что связано с затратами времени
* Где это возможно, используйте UNION ALL вместо UNION
* Для часто востребованных данных и сложных запросов используйте хранимые процедуры
* Используйте небольшие, насколько это возможно, транзакции, поскольку транзакция накладывает блокировку на обрабатываемые табличные данные, что может вызвать тупиковую ситуацию
* Избегайте использования некоррелирующих скалярных подзапросов. Используйте этот запрос как отдельный вместо части основного запроса и сохраняйте выходные данные в переменной, на которую можно ссылаться в основном запросе или в последующей части пакета.
* Избегайте многооператорных табличнозначных функций (TVF). Эти функции более затратны по сравнению со встроенными (inline) TVF
### Всякие СУБД под SQL
#### Greenplum
* Надстройка над PostgresSql для работы с BigData
#### Casandra
* Это нереляционная отказоустойчивая распределенная СУБД, рассчитанная на создание высокомасштабируемых и надёжных хранилищ огромных массивов данных, представленных в виде хэша
#### ClickHouse
* Cтолбцовая система управления базами данных (СУБД) для онлайн-обработки аналитических запросов (OLAP)
---
## Задачки
[Go Back](#оглавление)
* https://tproger.ru/articles/sql-interview-questions
* https://proglib.io/p/sql-questions
---
## Источники
[Go Back](#оглавление)
* https://habr.com/ru/articles/664000/
* https://proglib.io/p/funkcii-i-hranimye-procedury-v-sql-zachem-nuzhny-i-kak-primenyat-v-realnyh-primerah-2022-10-07
* https://info-comp.ru/what-is-ddl-dml-dcl-tcl
* https://timeweb.cloud/tutorials/sql/indeksy-v-sql-sozdanie-vidy-i-kak-rabotayut
* https://learn.microsoft.com/ru-ru/office/troubleshoot/access/database-normalization-description
* https://habr.com/ru/companies/latera/articles/281262/
