# Подготовка к собеседованию по Scala
## Оглавление
+ [Типы переменных](#Типы-переменных)
+ [Типы данных](#Типы-данных)
+ [Коллекции](#Коллекции) -- TODO
+ [Функции](#Функции)
    + [Функциональные значения](#Функциональные-значения)
    + [Замыкания](#Замыкания)
    + [Каррирование](#Каррирование)
    + [Хвостовая рекурсия](#Хвостовая-рекурсия) -- TODO
    + Функции высшего порядка?
+ [ООП](#ООП)
    + [Class](#Class)
    + [Object](#object)
        + [Объект-компаньон](#Объект-компаньон)
    + [Trait](#trait)
    + [Abstract class](#Abstract-class)
    + [Наследование](#Наследование)
        + [Линеризация](#Линеризация)
    + [Case class](#case-class)
---
## Другие файлы
* [Spark](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Spark.md)
* [Python](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Python.md)
* [SQL](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/SQL.md)
* [Общая информация](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Common.md)
* [Вопросы работодателю](https://github.com/Binary-hedgehog/-DataEngineer/blob/main/Questions%20for%20employer.md)
---
## Типы переменных
[Go Back](#оглавление)
* Изменяемость
    * в Scala все переменные делятся на две подгруппы mutable и imutable - то есть изменяемые и неизменяемые
* val - переменная данного типа инициализируется в начале работы программы и **не может** изменяться
* lazy val - переменная данного типа инициализируется в момент первого обращения к ней и **не может** изменяться
* var - переменная данного типа инициализируется в начале работы программы и **может** изменяться
* def - переменная данного типа инициализируется каждый раз при её вызове
---
## Типы данных
[Go Back](#оглавление)
### Основные типы
#### Числовые
* Целые
    * Byte - 8-битовое число 
    * Short - 16-битовое число 
    * Int - 32-битовое число 
    * Long - 64-битовое число 
* С плавающей точкой
    * Соответствуют стандарту [IEEE754](https://ru.wikipedia.org/wiki/IEEE_754-2008)
    * Float - 32-битовое число одинарной точности
    * Double - 64-битовое число двойной точности
#### Символьные 
* Char - 16-битовый Unicode-символ
* String - последовательность из Char
    * Неформатируемые строки оборачиваются в `"""your string"""`, вместо `"your string"`
        * Такие строки игнорируют управляющие последовательности и позволяют писать в несколько строк
        ``` Scala
        println("""Welcome to         
                   Scala, dude""")    
        // Welcome to
        //                Scala, dude
        ``` 
    * Интерполяция строк
        * **s** - после знака `$` к выражению применяется метод `toString`
           ``` Scala
           val a = 12  
           println(s"$a less then ${a * 2}") // 12 less then 24
           ``` 
        * **raw** - ведет себя как **s**, но игнорирует управляющие последовательности символьных литералов
           ``` Scala
           println(raw"AA\\bb") // AA\\bb
           ``` 
        * **f** - форматируемые строки, использующие синтаксис `java.util.Formatter`, в остальном ведет себя как **s**
           ``` Scala
           println(f"${math.Pi}%.5f") // 3.14159
           ``` 
#### Остальные
* Boolean - логический тип, принимающий значения `true` или `false`
* Unit - данный тип используется когда какая либо фкнкция/метод ничего не возвращают (что не очень функционально)
    * На самом деле они возврщают unit-значение `()`
   ``` Scala
   println("hi") == () // true
   ```
### Коллекции
* Any, Any val, Any seq, Nothing, Коллекции, 
* Множества, отображения
---
## Функции
[Go Back](#оглавление)
### Немножко про возможности функций в Scala
``` Scala
// Это функция
(x: Int) => x + 1
// Повторяющиеся аргументы
def foo(args: String*) = for {i <- args}{print(i)}
foo("aa", "?") // aa?
// Именованные аргументы
foo(args = "1")
// Аргументы по умолчанию
def bar(i: Int = 2) = println(i)
bar() // 2
```
### Функциональные значения 
``` Scala
def foo(x: Int, y: Int) = x + y
val a = foo // Это называется функциональное значение
// Использовать его можно, например, так
val b = foo(_, 5)
println(b(4)) // 9
```
* Держим в уме, что оптимизация хвостовой рекурсии не работает с функциональными значениями, только непосредственно с функциями
### Замыкания
* Замыкания - это когда функция может использовать и изменять переменные из внешней области видимости
``` Scala
var a = 2 // свободная переменная для функций foo и bar 
def bar(x: Int) = x * a
def foo(x: Int): Int = {
   a = x - a
   x + a
}
println(foo(6)) // 10
println(a)      // 4
println(bar(3)) // 12
```
* Когда функция без аргументов изменяет какие-либо внешние переменные своим вызовом (использует замыкания) стоит ставить пустые скобки `()`, в остальных же случаях их нужно опускать
``` Scala
 class Temp {
   private var count = 0
   def inc(): Unit = count += 1
   def getCount: Int = count
 }
val t = new Temp()
println(t.getCount) // 0
t.inc()
println(t.getCount) // 1
```
### Каррирование
* Это когда у функции появляется несколько списков аргументов
* Соответственно мы можем последовально проициализировать `x`, а потом уже `y` (см. пример ниже)
``` Scala
// Обычная функция
def plus(x: Int, y: Int) = x + y
// Каррированная функция
def plus(x: Int)(y: Int) = x + y
// А вот что в такой момент происходит под капотом
def plus(x: Int) = (y: Int) => x + y
```
### Хвостовая рекурсия
---
## ООП
[Go Back](#оглавление)
* Ниже разобраны основные шаблоны ООП в Scala
### Class
* Классы - это шаблоны объектов
``` Scala
// Создание класса
class TempClass1
class TempClass2(y: Int)
class SomeClass {
  def str: String = ""
  val s = 1
}
// Инициализация класса
val a = new TempClass1
val b = new TempClass2(2)

// 'val x' используется чтобы объявить переменную, к которой можно будет получать доступ извне класса (см. chooseMax)   
class SomeOtherClass(val x: String) { 
  // Устанавливаем требования к инициализации класса переменной 
  require( x != "" ) // функция объекта Predef
  // Создаем элементы класса
  private val a = 2 // Пример инкапсуляции
  def str: String = x + "!"
  // Вспомогательный конструктор, который позволяет инициализировать данный класс, например, через 2 переменные
  def this(a: String, b:String) = this(a + b)
  // Используем экземпляр созданного класса
  def chooseMax(abc: SomeOtherClass): SomeOtherClass = 
    if (x.length < abc.x.length) abc else this // 'this' - ключевое слово обращения к экземпляру данного класса
}
```
### Object
* Объект-одиночка (singleton) - существует в единственном экземпляре. Для создания используется ключевое слово `object`
* Объекты-одиночки не могут принимать параметры
* Экземпляр объекта нельзя создать с помощью `new`
    * Он реализуется как экземпляр синтетического класса, сслыка на который находится в статической переменной
#### Объект-компаньон
* Объект имеющий одинаковое название с классом является объектом-компаньоном
* Класс и объект-компаньон могут обращаться к приватным элементам друг друга
``` Scala
object A {
  private val a: Int = 2
  val cls: Int = new A().b 
}
class A {
  private val b: Int = A.a + 1
}
```
### Trait
* Зачастую используются для расширения функционала классов
* Так как являются абстрактными - не могут быть проинициализированы
* Ключевое отличие `trait` от `class` в том, что вызов `super` имеет динамическую, а не статическую привязку
    * Это значит, что примешивание `trait` к классу не переопределяет его родительский класс
* Примешанные трейты - это по сути миксины
* `trait` как и объекты-одиночки не принимают параметры
    * В Scala 3 могут принимать
### Abstract class
* `abstract` указывает на то, что у класса могут быть абстрактные члены
    * Абстракнтные члены класса - объекты не имеющие конкретной реализации
    * Из-за этого невозможно создать экземпляр данного класса
``` Scala
// Абстрактный класс
abstract class Some {
  // Абстрактный метод
  def foo: List[String]
  def len: Int = foo.length
}
new Some() // error
```
### Наследование
* В Scala наследование реализуется через `extends`
    * Обращение к суперклассу происходит через `super`
    * При этом суперклассом может быть кто угодно кроме
        * Объекта-одиночки `object`
        * Объекта с ключевым словом `final`, например, `final class`
* В Scala нет множественого наследования, однако, можно подмешивать любое количество `trait` к классу при помощи `with`
* Если суперкласс не задан, то им по умолчанию является `AnyRef`
* Что не наследуется
    * Приватные элементы суперкласса
    * Элемент суперкласса с таким же именем и параметрами, который реализован в подклассе
* Элементы суперкласса могут быть переопределены через `override`
    * Исключением является `final` элементы
``` Scala
abstract class A {
  val a: Int
  val b: Int = 2
}
class B extends A {
  val a = 2  // В данном классе должно быть определение обстрактной переменной a
  override val b = 3 // Переопределяем переменную b
}
trait C
trait D
class E extends B with C with D
```
* Для разрешения того в какой последовательности будут вызываться методы в подмешенных `trait` существует **линеризация**
#### Линеризация 
* Пример работы линеризации в Scala
    * Для удоства каждый `trait` принтует своё название, поэтому если выполнить код, то получим результат `XRAHTSB` теперь разберемся как нему прийти
``` Scala
trait X { print("X") }
trait R { print("R") }
trait A extends X with R { print("A") }
trait H { print("H") }
trait S extends H { print("S") }
trait T extends R with H { print("T") }

class B extends A with T with S { print("B") }
new B // XRAHTSB
```
* Чтобы разобраться разобраться в порядке исполнения всех подмешенных `trait` выпишем все зависимости класса `B`
    * Начинаем разбирать зависимости класса `В` слева направо, а провалившись вовнутрь суперкласса выписываем его зависимости справа налево (и так рекурсивно)
       1. trait A -> trait R -> trait X
       2. trait T -> trait H -> trait R
       3. trait S -> trait H
    * Теперь мы собираем все зависимости начиная с 1ой строки справа налево игнорируя дубли
        * Получаем следующую последовательность `trait` X, R, A, H, T, S - именно такая последовательность выполнения `trait` подмешенных в класс `B`, что соответствует результату представленному выше
### Case class
* Классы образцы - могут реализовывать методы на основе значений переданных конструктору
* Компилятор автоматически создает им фабричные методы `apply`, `toString`, `hashCode`, `equals`
* Компилятор хранит все параметры класса и генерирует методы доступа с соответствующим именем
``` Scala
case class P(x: Int, y: String)
val p = P(1, "two")  // Оно же P.applay(1, "two")
p.toString // P(1, "two")
p.x // 1
p.y // two
p == P(1, "two") // true
```
* При это компилятор не будет генерировать метод, который вы напишете самостоятельно, он будет использовать вашу реализацию
    * Что можно совместить с объектом-компаньоном
``` Scala
case class P(x: Int, y: String)
object P {
  def apply(x: Int, y: String): P = {
    new P(x + 1, y.capitalize)
  }
}
println(P(1, "sss")) // P(2,Sss)
```
---
---
дальше живут драконы )))
---
## ФП
* map, flatMap, filter, foldLeft, for comprehension, yeild
* "Моноид" "Монада" "Композиция монад"
## Option,
## Исключения
## 

## implicit
## Future
## Either
## Pattern matching
## Given
## Пакеты
* Predef


## Дополниетльные вопросы
* Nil, null, none, nothing
* Какие фреймворки поддерживает Scala
* Что такое объекты, методы, операторы, операнды, литералы, инфексная, постфиксная и преФиксная нотации
* метод - функция включенная в состав объекта
* Что это за ЯП


* Знание синтаксиса Scala и стандартной библиотеки: коллекций, Future, Option, Either и так далее
* Умение писать функциональный код (без Mutable State, While Loops и так далее) и пользоваться Cats и ZIO (если был опыт)
* What is a companion object?
* What is a functor?
* What is a applicative?
* Explain the actor model.
*  В чем разница между конкурентностью и параллелизмом?
*  


## Источники
* https://github.com/Jarlakxen/Scala-Interview-Questions?tab=readme-ov-file#reactive-programming-questions
* https://proglib.io/p/4-scala-questions
* https://stackoverflow.com/questions/34242536/linearization-order-in-scala
